
function find_ICC() {
    r1 = input_params.vehicle_length/Math.tan(input_params.articulation_angle) ?? Infinity;

    if (r1 === Infinity) {
        r4 = Infinity;
        r3 = Infinity;
        r2 = Infinity;
        r0 = Infinity;
        ICC = new THREE.Vector3(Infinity, -input_params.vehicle_length, 0);
    }
    else {
        r4 = Math.sqrt(Math.pow(r1, 2) - Math.pow(input_params.vehicle_length,2));
        r3 = r4 + input_params.vehicle_width;
        r2 = Math.sqrt(Math.pow(r3,2) + Math.pow(input_params.vehicle_length,2));
        r0 = Math.sqrt(Math.pow(input_params.vehicle_length,2) + Math.pow(input_params.vehicle_width/2 + r4,2));
        ICC = input_params.articulation_angle > 0 ? new THREE.Vector3(r3, -input_params.vehicle_length, 0) : new THREE.Vector3(-r4, -input_params.vehicle_length, 0);    
    }

    // draw ICC as circle
    const circle_geometry = new THREE.CircleGeometry( 0.1, 32 );
    const circle_material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
    const circle = new THREE.Mesh( circle_geometry, circle_material );
    circle.position.add(ICC);
    scene.add( circle );

    // draw lines from ICC to vehicle upper wheel and lower wheel
    const ICC_to_upper_wheel = new THREE.BufferGeometry().setFromPoints( [ICC, new THREE.Vector3(input_params.vehicle_width, 0, 0)] );
    const ICC_to_lower_wheel = new THREE.BufferGeometry().setFromPoints( [ICC, new THREE.Vector3(0, 0, 0)] );
    const ICC_to_middle = new THREE.BufferGeometry().setFromPoints( [ICC, new THREE.Vector3(input_params.vehicle_width/2, 0, 0)] );
    const ICC_to_upper_wheel_line = new THREE.Line( ICC_to_upper_wheel, circle_material );
    const ICC_to_lower_wheel_line = new THREE.Line( ICC_to_lower_wheel, circle_material );
    const ICC_to_middle_line = new THREE.Line( ICC_to_middle, circle_material );
    scene.add( ICC_to_upper_wheel_line );
    scene.add( ICC_to_lower_wheel_line );
    scene.add( ICC_to_middle_line );

    // add two arcs around ICC with radius r1 and r2
    const curve1 = new THREE.EllipseCurve( ICC.x, ICC.y, r1, r1, 0, 2*Math.PI, input_params.articulation_angle > 0 ? true: true, 0 );
    const curve2 = new THREE.EllipseCurve( ICC.x, ICC.y, r2, r2, 0, 2*Math.PI,  input_params.articulation_angle > 0 ? true: true, 0 );
    const points1 = curve1.getPoints( 50 );
    const points2 = curve2.getPoints( 50 );
    const geometry1 = new THREE.BufferGeometry().setFromPoints( points1 );
    const geometry2 = new THREE.BufferGeometry().setFromPoints( points2 );
    const material = new THREE.LineBasicMaterial( { color : 0xffff00 } );
    const ellipse1 = new THREE.Line( geometry1, material );
    const ellipse2 = new THREE.Line( geometry2, material );
    scene.add( ellipse1 );
    scene.add( ellipse2 );
}